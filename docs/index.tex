% Created 2020-07-31 Fri 16:37
% Intended LaTeX compiler: pdflatex
\documentclass[11pt]{article}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{graphicx}
\usepackage{grffile}
\usepackage{longtable}
\usepackage{wrapfig}
\usepackage{rotating}
\usepackage[normalem]{ulem}
\usepackage{amsmath}
\usepackage{textcomp}
\usepackage{amssymb}
\usepackage{capt-of}
\usepackage{hyperref}
\author{Hee Hwang}
\date{\textit{<2020-07-31 Fri>}}
\title{Pathtracer++: GPU-Enabled Pathtracer}
\hypersetup{
 pdfauthor={Hee Hwang},
 pdftitle={Pathtracer++: GPU-Enabled Pathtracer},
 pdfkeywords={},
 pdfsubject={},
 pdfcreator={Emacs 26.3 (Org mode 9.1.9)}, 
 pdflang={English}}
\begin{document}

\maketitle
\setcounter{tocdepth}{2}
\tableofcontents


\section*{Title, Summary and Team Members}
\label{sec:orgfdb4ca8}
This project improves the performance of the previous raytracing
projects written in OpenGL. This project utilize modern GPU
technology and significantly shorten the rendering time. 

\section*{Problem Description}
\label{sec:org92befbd}
The problem of the previous OpenGL based raytracer is that it only
uses CPUs whose performance is capped on the limited number of
cores.  A simple global illumination rendering takes a several
minutes, and this could be problematic when rendering complex
scenes.  Currently, all logics in the previous project assume we use
CPUs. This means a fair amount of code must be optimized and
rewritten. I will implement a vanila raytracer using the previous
project\footnote{\url{https://cal-cs184-student.github.io/p3-1-pathtracer-su20-heeh/}} and Apple Metal performance shader\footnote{\url{https://developer.apple.com/documentation/metalperformanceshaders/metal\_for\_accelerating\_ray\_tracing}}. In a
nutshell, I will optimize and rewrite raytracing logics that pushes
the GPU to its maximum limit.

\section*{Goals and Deliverables}
\label{sec:orgc556aae}
\subsection*{Pathtracer Implementation that support GPU processing}
\label{sec:orgc70b674}
Apple Metal Shader requires us to write code in either objective-c
or swift, which means that I have to implement a pathtracer from
scratch.  This would be fun, but I will use opengl if this will not
be feasible given timeline.

\subsection*{Parallel logic implementation}
\label{sec:orgf942f08}
In the previous project, we process pixel by pixel to compute
spectrum on the pixel.  This is an iterative process and I will
setup BVH as a readable GPU buffer.  The tricky part is to remove
recursion in global illumination. This is something that I need to
figure out later.

\subsection*{Performance Comparison}
\label{sec:org4f0d9f1}
I will present the performance of the program by measuring the
rendering speedup and memory usage.

\subsection*{Additinal Shaders using Different Lighting}
\label{sec:orgf93439d}
Assume I improved the pathtracer, I want to change lighting using different shaders.
This is something that I hope to deliever at the end of the semester.

\section*{Schedule}
\label{sec:orgf3b40f5}
Week1(8/1/2020 - 8/7/2020) Implement vanila pathtracer without GPU acceleration
Week2(8/8/2020 - 8/14/2020) Parallel Logic, pepformance, and additional lighting

\section*{Resources}
\label{sec:org7766bdb}
\subsection*{Computing platform}
\label{sec:orgea31ab6}
\begin{itemize}
\item Macbook Pro(2019)
\item CPU: 2.6 GHz 6-Core Intel Core i7
\item RAM: 16 GB 2667 MHz DDR4
\item GPU: AMD Radeon Pro 5300M 4 GB
\end{itemize}
\subsection*{Online materials}
\label{sec:org04bec7b}
\begin{itemize}
\item OpenGL Pathtracer Implemetation \url{https://cal-cs184-student.github.io/p3-1-pathtracer-su20-heeh/}
\item Apple Metal Shader \url{https://developer.apple.com/documentation/metalperformanceshaders/metal\_for\_accelerating\_ray\_tracing}
\end{itemize}
\end{document}
